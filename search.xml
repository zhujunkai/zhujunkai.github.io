<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[系统分析与设计-hw1]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-03-12-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-hw1.html</url>
    <content type="text"><![CDATA[1.软件工程的定义# &nbsp;&nbsp;&nbsp;&nbsp;软件工程是将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件 2.解释导致 software crisis 本质原因、表现，述说克服软件危机的方法# &nbsp;&nbsp;&nbsp;&nbsp;本质原因：计算机的发展 表现：计算能力按摩尔定律发展，软件处理的问题也越来越广、越来约复杂 克服软件危机的方法：软件生产不只是编程技术问题，需要有系统化、与时俱进的软件工程方法，才能规避 software crisis ！ 3.软件生命周期# &nbsp;&nbsp;&nbsp;&nbsp;在时间维度，对软件项目任务进行划分，又成为软件开发过程。常见有瀑布模型、螺旋模型、敏捷的模型等。 4.SWEBoK 的 15 个知识域# 软件需求：软件要求KA关注软件需求的启发，协商，分析，规范和验证。 软件设计：软件设计KA涵盖了设计过程和最终产品。软件设计过程是软件工程生命周期活动，其中分析软件需求以产生软件内部结构及其行为的描述，其将作为其构造的基础。 软件构造：软件构建是指通过结合详细设计，编码，单元测试，集成测试，调试和验证来详细创建工作软件。 软件测试：测试是一项旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。 软件维护：软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。这些类别称为完善，自适应和纠正性软件维护。 软件配置管理：软件配置管理（SCM）是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。 软件工程管理：软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。 软件工程过程：软件工程KA关注软件生命周期过程的定义，实施，评估，测量，管理和改进。 软件工程模型和方法：软件工程模型和方法KA解决了涵盖多个生命周期阶段的方法; 其他KAs涵盖特定生命周期阶段的特定方法。 软件质量：软件质量是许多SWEBOK V3 KAs中普遍存在的软件生命周期问题。此外，软件质量KA还包括软件质量的基础知识; 软件质量管理流程; 和实际考虑。 软件工程职业实践：软件工程专业实践关注软件工程师必须具备的专业，负责和道德的软件工程知识，技能和态度。 软件工程经济学：软件工程经济学KA关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。 计算基础：计算基础KA涵盖了提供软件工程实践所需的计算背景的基础主题。 数学基础：数学基础KA涵盖了提供软件工程实践所必需的数学背景的基础主题。 工程基础：工程基础KA涵盖了提供软件工程实践所必需的工程背景的基础主题。 5.简单解释 CMMI 的五个级别。# 初始级：软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。 可管理级：建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。 已定义级：已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。 量化管理级：分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。 优化管理级：过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。 6.用自己语言简述 SWEBok 或 CMMI （约200字）# SWEBok就是软件工程知识体系指南，大致的讲述了一些主要的软件工程知识域，表明了软件工程的学科内容（包括工程和教育两个方面），把软件工程与其他学科的区别，帮助大家对软件工程有一致的观点。 CMMI就是软件能力成熟度集成模型，将一个组织划分成了几个不同的阶段级，需要不同的管理和开发结构。相比起普通的单一的组织框架，CMMI相对而言就更加灵活，可扩展，从总体上改进组织的质量和效率。CMMi包含了很多种管理，过程管理应该是用来帮助组织成长，项目管理可以让组织更加高效，稳定，工程管理则提供了更佳合理软件工程开发流程，就还有支持管理等等，通过这些标准可以快速的帮助一个组织建立以及发展，CMMI模型可以确保组织的更好的阶段性和连续性。]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
        <tag>hw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gRPC]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2019-01-19-gRPC.html</url>
    <content type="text"><![CDATA[简介# gRPC是一个高性能、开源和通用的RPC框架，面向移动和HTTP/2设计。 目前提供C、Java和Go语言版本，分别是grpc、grpc-java、grpc-go。 gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。 这些特性使得其在移动设备上表现更好，更省电和节省空间占用。 gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统。 gRPC是什么# 在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同机器上服务端应用的方法， 使得你能够更容易地创建分布式应用和服务。与许多RPC系统类似，gRPC也是基于以下理念： 定义一个服务，指定其能够被远程调用的方法（包括参数和返回类型）。 在服务端实现这个接口，并运行一个gRPC服务器来处理客户端调用。 在客户端拥有一个存根能够像服务端一样的方法。 gRPC客户端和服务端可以在多种环境中运行和交互，从google内部的服务器到你的笔记本，并且可以使用任何gRPC支持的语言编写。 所以你可以很容易滴用Java创建一个gRPC服务端，用go、python、ruby来创建客户端。 此外，google最新api将有gRPC版本的接口，使你很容易地将Google的功能集成到你的应用中。 安装# 1.安装 Protocol Buffers 12$ go get -u google.golang.org/grpc$ go get -u github.com/golang/protobuf/protoc-gen-go 2.安装gRPC-go gRPC-go可以通过golang 的get命令直接安装，非常方便。 1$ go get google.golang.org/grpc 3.编译例子 例子是gRPC-go的examples的helloworld,先看PB的描述： 123456789101112131415161718192021syntax = &quot;proto3&quot;;option objc_class_prefix = &quot;HLW&quot;;package helloworld;// The greeting service definition.service Greeter &#123; // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;&#125;// The request message containing the user&apos;s name.message HelloRequest &#123; string name = 1;&#125;// The response message containing the greetingsmessage HelloReply &#123; string message = 1;&#125; 使用protoc命令生成相关文件： 1$ protoc --go_out=plugins=grpc:. helloworld.proto 然后就会生成对应的pb.go文件了 4.编译运行 服务端 1$ go run greeter_server/main.go 客户端 1$ go run greeter_client/main.go 如果运行成功的话，可以在客户端看到 Greeting: Hello world。 5.代码部分： greeter_server/main.go声明并实现了 gRPC 的服务 SayHello 12345// SayHello implements helloworld.GreeterServerfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) &#123; log.Printf(&quot;Received: %v&quot;, in.Name) return &amp;pb.HelloReply&#123;Message: &quot;Hello &quot; + in.Name&#125;, nil&#125; greeter_client/main.go: 12345678// 连接 gPRC 服务conn, err := grpc.Dial(address, grpc.WithInsecure())// 创建一个 protobuf 客户端c := pb.NewGreeterClient(conn)// 调用 protobuf 的 SayHello 服务r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>服务计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swapi-xd]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-12-16-Swapi-xd.html</url>
    <content type="text"><![CDATA[Vue构建swapi前端的心得# 这次制作swapi的前端使用了vue架构，这个架构确实很方便，大致上的模仿复制了swpai的网站 开发过程# vue-cli的基本结构 我们需要去修改的文件基本上就是那个src里面的文件了。 首先是App.vue，在这里我主要书写了关于整个页面外面的框架，然后通过点击里面导航栏里面的按钮结合router实现相对应的页面跳转。 并且在js文件里面配置那个router 然后根据页面的内容进行相应的布局，在about和docu两个页面里面使用markdown-loader去允许读取md文件，并且vue-markdown去显示md文件。 然后在md内置a的tag就可以实现那个点击的跳转了。 在主页面里面用一个pre去显示那个json的输出口 关于那个api的请求，则是使用axios去发出请求并且处理response就可以显示结果了。 最后网页是大致与原站差不多的。]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>服务计算</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go的web小程序及http包分析]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-11-15-Go-http.html</url>
    <content type="text"><![CDATA[简单的web服务器# 这是一个简单的输出hello world！的web服务器，只用在客户端访问 http://localhost:9090/ 就可以获得响应内容。 1234567891011121314151617181920package mainimport ( "fmt" "net/http" "strings" "log")func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte("Hello World!"))&#125;func main() &#123; http.HandleFunc("/", sayhelloName) //设置访问的路由 err := http.ListenAndServe(":9090", nil) //设置监听的端口 if err != nil &#123; log.Fatal("ListenAndServe: ", err) &#125;&#125; 这段代码很简单，就主要是是用了两个函数，首先调用http.HandleFunc()设置路由和响应处理函数，然后用http.ListenAndServe()去监听端口，就好了。 HandleFunc()分析# http.HandleFunc()的定义，用来使用对应的函数。 1234// HandleFunc registers the handler function for the given pattern.func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123; mux.Handle(pattern, HandlerFunc(handler))&#125; 可以看出来上面就是用来mux.Handle函数，Http包默认的路由器：DefaultServeMux, 它的ServeMux的结构看起来好像很简单。 上述代码中，实现了Handler接口的ServeHTTP方法。使用HandlerFunc类型包装一下路由定义的indexHandler函数，其目的就是为了让这个函数也实现ServeHTTP方法，即转变成一个handler处理器(函数)。 12345678910type ServeMux struct &#123; mu sync.RWMutex m map[string]muxEntry hosts bool &#125;type muxEntry struct &#123; explicit bool h Handler pattern string&#125; ServeMux里最重要的应该就是m了，这个map的key是一些url模式，value是一个muxEntry结构，后者里定义存储了具体的url模式和handler。 根据HandleFunc的输入就可以，开始调用mux.Handle函数了。 12345678910111213141516171819202122232425262728293031323334353637// Handle registers the handler for the given pattern.// If a handler already exists for pattern, Handle panics.func (mux *ServeMux) Handle(pattern string, handler Handler) &#123; mux.mu.Lock() defer mux.mu.Unlock() if pattern == "" &#123; if pattern == "" &#123; panic("http: invalid pattern " + pattern) &#125; if handler == nil &#123; panic("http: nil handler") &#125; if mux.m[pattern].explicit &#123; panic("http: multiple registrations for " + pattern) &#125; if mux.m == nil &#123; mux.m = make(map[string]muxEntry) &#125; mux.m[pattern] = muxEntry&#123;explicit: true, h: handler, pattern: pattern&#125; if pattern[0] != '/' &#123; mux.hosts = true &#125; n := len(pattern) if n &gt; 0 &amp;&amp; pattern[n-1] == '/' &amp;&amp; !mux.m[pattern[0:n-1]].explicit &#123; path := pattern if pattern[0] != '/' &#123; path = pattern[strings.Index(pattern, "/"):] &#125; url := &amp;url.URL&#123;Path: path&#125; mux.m[pattern[0:n-1]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125; &#125;&#125; 由此可见，Handle函数的主要目的在于把handler和pattern模式绑定到map[string]muxEntry的map上，其中muxEntry保存了更多pattern和handler的信息， ListenAndServe()分析# 1234func ListenAndServe(addr string, handler Handler) error &#123; server := &amp;Server&#123;Addr: addr, Handler: handler&#125; return server.ListenAndServe()&#125; 先实例化一个Server对象，然后调用 (Server) ListenAndServe()方法进行监听： 1234567891011func (srv *Server) ListenAndServe() error &#123; addr := srv.Addr if addr == "" &#123; addr = ":http" &#125; ln, err := net.Listen("tcp", addr) //监听端口 if err != nil &#123; return err &#125; return srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)&#125; 函数 srv.Serve()函数启动一个for循环，然后在循环体中Accept请求，对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()。 1234567891011121314151617181920212223242526272829func (srv *Server) Serve(l net.Listener) error &#123; defer l.Close() var tempDelay time.Duration // how long to sleep on accept failure for &#123; rw, e := l.Accept() //通过Listener接收请求 if e != nil &#123; if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123; if tempDelay == 0 &#123; tempDelay = 5 * time.Millisecond &#125; else &#123; tempDelay *= 2 &#125; if max := 1 * time.Second; tempDelay &gt; max &#123; tempDelay = max &#125; log.Printf("http: Accept error: %v; retrying in %v", e, tempDelay) time.Sleep(tempDelay) continue &#125; return e &#125; tempDelay = 0 c, err := srv.newConn(rw) //创建一个Conn。Conn是net包里面的一个接口 type Conn interface。Conn接口代表通用的面向流的网络连接。多个线程可能会同时调用同一个Conn的方法。 if err != nil &#123; continue &#125; go c.serve() //Go语言高并发的体现 &#125;&#125; 搭建一个web服务器# 一个简单的服务器，所以就没有使用牛逼的框架，就用了老师给的 “github.com/codegangsta/negroni&quot;、“github.com/gorilla/mux”、&quot;github.com/unrolled/render” 这三个。 Server注册路由# 用HandleFunc给每种访问提供对应的处理路由。 表单处理# 通过PaeseForm，提取表单内部的数据值。 处理完回应# 将你的数据转化成页面写上去。 实现效果# 登入 注册，传表单 登入查看对应内容 静态文件服务 /unknown 代码连接]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>服务计算</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7下搭建Golang]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-09-27-Go-some.html</url>
    <content type="text"><![CDATA[配置VSCode# 官方教程 首先，必须明确的是CentOS即不是Debian也不是Ubuntu，所以不要输入最上面的那几行命令。要输入后面的那一坨,一步一步走就好。 安装密钥和存储库# 12sudo rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo sh -c &apos;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&apos; 更新包缓存并安装包# 因为CentOS比较low，使用旧版的yum： 12yum check-updatesudo yum install code VScode的位置# 由于桌面上并没有这玩意儿，所以需要到应用程序里面找。 下载安装 golang# 1sudo yum install golang 就会自动下载安装包的了，下载完后会问你是否安装的，输入y继续安装好就行。 1rpm -ql golang |more 查询golang的安装路径 1go version 查看go的版本 配置go环境# 因为go安装的时候已经自动的设置了一个默认的环境，可以用go env来查看当前的go环境设置，会发现GOPATH=“/root/go”，这会导致一些权限问题，所以最好还是要修改一下环境的配置。 创建工作空间 1mkdir $HOME/gowork 配置的环境变量,把下面的代码添加到[~/.profile]里面。 12export GOPATH=$HOME/goworkexport PATH=$PATH:$GOPATH/bin 使环境变量生效 1source $HOME/.profile 现在可以再查看一下环境看一下变化 1go env 创建一个helloworld# 创建源代码目录： 1mkdir $GOPATH/src/github.com/github-user/hello -p 使用 vs code 创建 hello.go 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Printf(&quot;hello, world\n&quot;)&#125; 在终端运行! 12$ go run hello.gohello, world 这样简单的helloworld程序就完成了。 安装工具插件# 安装git# go 语言的插件主要在 Github 上，安装 git 客户端是首要工作。 1$ sudo yum install git 接着就是去配置一下git 12$ git config --global user.name &quot;你的名字&quot;$ git config --global user.email 你的邮箱 git的基本操作就不多说了。 安装 go 的一些工具# vscode会提示我们去安装一些插件，但很难受的是有些插件不能成功安装，“Failed”，所以需要在github里面寻求帮助。 123456# 创建文件夹mkdir $GOPATH/src/golang.org/x/# 下载源码go get -d github.com/golang/tools# copy cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf 此处，本人不知道遇到了什么问题，第二步发生了什么，无法直接下载源代码，此处别人都是正常的！ 我没有发现问题根源，于是选择直接去git clone下文件，拖进文件夹里，貌似并不会影响下面的操作,某个lint的插件同理可得。 1git clone https://github.com/golang/tools.git 接下来就是安装工具包 1$ go install golang.org/x/tools/go/buildutil 然后，在登入到VScode里，跟之前一样点那个提示安装就可以“Succeed”了！ 接下来就可以安装运行hello world了 12$ go install github.com/github-user/hello$ hello Go Tour# 这就是一个go的基本操作教程，安装完就可以直接用了，可以在线编程测试，相当方便，适合go语言的练习使用。 安装 1$ go get github.com/Go-zh/tour/gotour 运行 1$ gotour 这样就基本完成了CentOS的环境搭建，接下来就可以开始Go语言之旅了！！！]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>服务计算</tag>
        <tag>颓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware 搭建私有云]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-09-20-Pri-cloud.html</url>
    <content type="text"><![CDATA[1.实验目的# 1.初步了解虚拟化技术，理解云计算的相关概念 2.为后续课程提供统一的编程与实验环境 3.理解系统工程师面临的困境 2.实验环境与要求# 用户通过互联网，使用微软远程桌面，远程访问你在PC机上创建的虚拟机 虚拟机操作系统 Centos，Ubuntu，或 你喜欢的 Linux 发行版，能使用 NAT 访问外网。 3. 实验内容# 1.安装 VMWare# 进入官网，选择合适版本的VMWare进行下载，并根据流程一步一步的完成安装. &nbsp; [官网下载](https://www.vmware.com/) 2.使用VMware配置虚拟机# 创建一个虚拟机。这里选择的是CentOS7的精简版（Minimal ISO），可以在CentOS官网下载（节点可选择清华开源镜像站高速下载，速度较快）。 打开VMWare，创建虚拟机： 创建新的虚拟机 选择“典型（推荐）” 客户机操作系统选择Linux，版本为CentOS 64位(VMWare会自动识别，在VBox这里不要改版本，因为CentOS本身就是继承Red Hat的系统) 选择虚拟机安装位置 磁盘大小选择30g或以上 内存选择2G ，双核（有条件就不用拘泥了） 完成 接着，就是虚拟机网络设置，VMWare已经配置好了NAT模式和仅主机模式，所以进入后就可以直接连外网和主机了。 3.安装虚拟机# 启动虚拟机会进入centos的安装程序。按照安装程序一步一步来。 安装位置，选择自动分区即可 打开”网络与主机名“设置，把网卡打开，并且修改主机名 开始安装 设置root密码，可以创建用户 安装完重启,登入时如果没有用户，则可用用户名为root的方式登入 升级os内核 yum install wget 获取 wget yum update 升级 OS 内核。 检查网络 ping www.baidu.com 检查外网(这里我之前出现了一个DNS域名解析的bug，误以为网络问题，且未解决，可尝试连接外网的ip，如百度的119.75.217.109) ping 192.168.100.1 检查内网 ifconfig 查看网络 nmtui 配置网络 4.复制虚拟机# 右键点击centos-base虚拟机，选择【管理】-&gt;【克隆】 选择链接复制 VMWare应该是自带修改MAC地址的，就不用手动改了 vim /etc/ssh/sshd_config把里面Port 22前的#去掉，以及PermitRootLogin yes前面的#去掉。 然后service sshd start开启服务 用ssh 用户名@虚拟机ip地址去访问虚拟机 5.远程连接# 选择编辑–虚拟网络编辑器 点击NAT设置，弹出一个设置窗口 添加一个端口转发 配置路由器 就可以通过WAN口IP连接了(ssh -p 端口号 用户名@WAN口IP) 6.远程桌面连接# yum -y groupinstall &quot;GNOME Desktop&quot; 安装桌面 ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 设置启动目标为桌面 重启 安装epel 、xrdp、tigervnc-server yum install epel-release yum install xrdp yum install tigervnc-server 关闭防火墙，启动xrdp systemctl stop firewalld systemctl disable firewalld systemctl start xrdp systemctl enable xrdp 这样就实现了远程桌面连接]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>服务计算</tag>
        <tag>云</tag>
        <tag>颓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F2016-11-09-hello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start# Create a new post# 1$ hexo new "My New Post" More info: Writing Run server# 1$ hexo server More info: Server Generate static files# 1$ hexo generate More info: Generating Deploy to remote sites# 1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
