<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[go-viper]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-06-26-go-viper.html</url>
    <content type="text"><![CDATA[Go Echo使用viper实现配置模块# 1.什么是Viper？# > Viper是Go应用程序的完整配置解决方案。它旨在在应用程序中工作，并可以处理所有类型的配置需求和格式。 它支持： 设置默认值 从JSON，TOML，YAML，HCL和Java属性配置文件中读取 实时观看和重新读取配置文件（可选） 从环境变量中读取 从远程配置系统（etcd或Consul）读取，并观察变化 从命令行标志读取 从缓冲区读取 设置显式值 Viper可以被认为是所有应用程序配置需求的注册表。 为何选择Viper？# 构建应用程序时，不必担心配置文件格式。Viper就是为此提供帮助的。很多时候，我们服务器启动之后，如果临时想修改某些配置参数，需要重启服务器才能生效，但是viper提供了监听函数，可以免重启修改配置参数，非常的实用. Viper读取配置文件# Viper需要最少的配置让它知道在哪里查找配置文件。Viper支持JSON，TOML，YAML，HCL和Java Properties文件。Viper可以搜索多个路径，但目前单个Viper实例仅支持单个配置文件。Viper不会默认使用任何配置搜索路径，而是取决于应用程序的定义。 以下是如何使用Viper搜索和读取配置文件的示例。不需要任何特定路径，但应在预期配置文件的位置提供至少一个路径。 12345678viper.SetConfigName("config") // 配置文件的名称（没有扩展名）viper.AddConfigPath("/etc/appname/") // 查找配置文件的路径。viper.AddConfigPath("$HOME/.appname") // 多次调用以添加许多搜索路径viper.AddConfigPath(".") // 可选择在工作目录err := viper.ReadInConfig() // 查找并读取配置文件，if err != nil &#123; // 处理读取配置文件的错误 panic(fmt.Errorf("Fatal error config file: %s \n", err))&#125; 监听并重新读取配置文件: Viper支持在运行时让应用程序实时读取配置文件。 viper驱动的应用程序可以在运行时读取配置文件的更新，而不会错过任何一个节拍。 只需告诉viper实例watchConfig即可。您可以选择为Viper提供每次发生更改时运行的功能。 确保在调用之前添加所有configPath WatchConfig() 1234viper.WatchConfig()viper.OnConfigChange(func(e fsnotify.Event) &#123; fmt.Println("Config file changed:", e.Name)&#125;) Viper使用环境变量# Viper完全支持环境变量。有四种方法可以帮助使用ENV： 1234AutomaticEnv()BindEnv(string...) : errorSetEnvPrefix(string)SetEnvKeyReplacer(string...) *strings.Replacer BindEnv需要一个或两个参数。第一个参数是键名，第二个是环境变量的名称。环境变量的名称区分大小写。如果未提供ENV变量名，则Viper将自动假设密钥名称与ENV变量名称匹配，但ENV变量为IN ALL CAPS。当您明确提供ENV变量名称时，它不会自动添加前缀。 使用ENV变量时要认识到的一件重要事情是每次访问时都会读取该值。Viper在BindEnv调用时不会修复该值。 AutomaticEnv尤其是当与结合了强大的帮手 SetEnvPrefix。调用时，Viper将在任何viper.Get请求发出时检查环境变量。它将适用以下规则。它将检查一个环境变量，其名称与大写的键匹配，并以EnvPrefix前缀。 SetEnvKeyReplacer允许您使用strings.Replacer对象重写Env键到一定程度。如果要-在Get()调用中使用或使用某些内容 ，但希望环境变量使用_分隔符，则此选项非常有用。可以在中找到使用它的示例viper_test.go Viper的简单使用# Viper 也可以非常方便地读取多个层级的配置，比如这样一个 YAML 格式的配置： 123456common: db: name: db addr: 127.0.0.1:3306 username: root password: root 如果要读取name，只需要执行viper.GetString(“common.db.name”)就可以 下面来一个简单的例子介绍Viper： config/config.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package configimport ( "strings" "github.com/fsnotify/fsnotify" "github.com/spf13/viper")type Config struct &#123; Name string&#125;func Init(cfg string) error &#123; c := Config&#123; Name: cfg, &#125; // 初始化配置文件 if err := c.initConfig(); err != nil &#123; return err &#125; c.watchConfig() return nil&#125;func (c *Config) initConfig() error &#123; if c.Name != "" &#123; // 如果指定了配置文件，则解析指定的配置文件 viper.SetConfigFile(c.Name) &#125; else &#123; // 如果没有指定配置文件，则解析默认的配置文件 viper.AddConfigPath("conf") viper.SetConfigName("config") &#125; // 设置配置文件格式为YAML viper.SetConfigType("yaml") // viper解析配置文件 if err := viper.ReadInConfig(); err != nil &#123; return err &#125; return nil&#125;// 监听配置文件是否改变,用于热更新func (c *Config) watchConfig() &#123; viper.WatchConfig() viper.OnConfigChange(func(e fsnotify.Event) &#123; fmt.Printf("Config file changed: %s\n", e.Name) &#125;)&#125;]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>系统分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go_echo_jwt]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-06-26-go-echo-jwt.html</url>
    <content type="text"><![CDATA[Go Echo使用JWT实现Token认证# 1.为什么使用JWT？# 随着技术的发展，分布式web应用的普及，通过session管理用户登录状态成本越来越高，因此慢慢发展成为token的方式做登录身份校验，然后通过token去取redis中的缓存的用户信息，随着之后jwt的出现，校验方式更加简单便捷化，无需通过redis缓存，而是直接根据token取出保存的用户信息，以及对token可用性校验，单点登录更为简单。 2.JWT架构图# 3.JWT的结构# JWT由三部分组成，它们之间用圆点(.)连接。这三部分分别是： Header Payload Signature 因此，一个典型的JWT看起来是这个样子的： xxxxx.yyyyy.zzzzz Header:# header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等） Payload:# JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。 Header:# 为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。 4.JWT是如何工作的# 在认证的时候，当用户用他们的凭证成功登录以后，一个JWT将会被返回。此后，token就是用户凭证了。 无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中。 1Authorization: Bearer &lt;token&gt; 服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。 如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。 5.用Token的好处# * 无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。 * 安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话! 6.JWT使用(golang)# 使用go的一个库 1&quot;github.com/jwt-go&quot; 123456789101112131415* Token生成```gofunc createToken(key string, m map[string] interface&#123;&#125;) string&#123; token := jwt.New(jwt.SigningMethodHS256) claims := make(jwt.MapClaims) for index, val := range m &#123; claims[index] = val &#125; // fmt.Println(_map) token.Claims = claims tokenString, _ := token.SignedString([]byte(key)) return tokenString&#125; 获取内容 1234567891011121314func parseToken(tokenString string, key string) (interface&#123;&#125;, bool)&#123; token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface&#123;&#125;, error) &#123; if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok &#123; return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"]) &#125; return []byte(key), nil &#125;) if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid &#123; return claims, true &#125; else &#123; fmt.Println(err) return "", false &#125;&#125;]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>系统分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-hw6]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-05-04-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-hw6.html</url>
    <content type="text"><![CDATA[1、使用类图，分别对 Asg_RH 文档中 Make Reservation 用例以及 Payment 用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键 注意事项： 对象必须是名词、特别是技术名词、报表、描述类的处理； 关联必须有多重性、部分有名称与导航方向 属性要注意计算字段 数据建模，为了简化描述仅需要给出表清单，例如： Hotel（ID/Key，Name，LoctionID/Fkey，Address……） Hotel (ID/Key, LocationID/FKey, Name, Address, Star, Brief-intro, isFavourites, isLowestPrice, isHigestStarRating, isAlphabetical)) Location (ID/Key, Name, isFavourite) Room (ID/Key, HotelID/FKey, Type, Date, isAvailable, isReserved, Price) Traveler (ID/Key, Name, Email) Reservation (ID/Key, TravelerID/FKey, HotelID/FKey, CheckInDate, NumberofNights) ReservationItem (ID/Key, ReservationID/FKey, RoomID/Fkey, AdultsNum, ChildrenNum, ChildrenAge) Payment (ID/Key, ReservationID/FKey, Date, Time, Total) PaymentItem (ID/Key, PaymentID/FKey, Details) CreditCard (ID/Key, CustomerID/FKey, PaymentID/FKey, Type) CreditCardDetail (ID/Key, CreditCardID/FKey, PaymentItemID/FKey, Number, SecurityCode, ExpiryDate) AddressDetail (ID/Key, PaymentItemID/FKey, Name, Address, City, State, Country) 2、使用 UML State Model，对每个订单对象生命周期建模 建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。 建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
        <tag>hw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-hw5]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-05-04-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-hw5.html</url>
    <content type="text"><![CDATA[1、根据订旅馆建模文档，Asg-RH.pdf： 绘制用例图模型（到子用例） 给出 make reservation 用例的活动图 2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景 分别用多泳道图建模三个场景的业务过程 根据上述流程，给出快递柜系统最终的用例图模型 用正常色彩表示第一个业务流程反映的用例 用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor 用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
        <tag>hw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-hw4]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-04-10-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-hw4.html</url>
    <content type="text"><![CDATA[1、简答题 用例的概念 用例是软件工程或系统工程中对系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。 用例和场景的关系？什么是主场景或 happy path？ 每个用例提供了一个或多个场景，该场景说明了系统是如何和最终用户或其它系统互动，也就是谁可以用系统做什么，从而获得一个明确的业务目标。 主成功场景是用例最基本的组成部分,它描述了满足涉众关注点的典型成功路径。 用例有哪些形式？ 在不同的团队情况也可能导致用例书写的不一样。比如在一个大型的开发项目组里，就需要严格的按照用例范例进行描述，而在一个小型的沟通频繁的项目组里，则可以采用一种比较简单的描述方式。 用例的格式有：完整正式的格式、非正式、单列表格式、双列表格式、RUP格式、条件语句格式、Occam格式、图形方式、UML用例图 对于复杂业务，为什么编制完整用例非常难？ 复杂的业务，会涉及到很多的参与者，场景，实例之类的，而且会难以耦合，因此，对于这种业务，会很难去编制一个相对完整的用例。 什么是用例图？ 用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。用例图（User Case）是外部用户（被称为参与者）所能观察到的系统功能的模型图。用例图是系统的蓝图。用例图呈现了一些参与者，一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行建模。 用例图的基本符号与元素？ 小人：参与者。 椭圆：用例 大方框：系统，可以是小型软件组件，也可以是完整的应用程序，里面包含外部可见的功能。 箭头：参与者和系统通过相互发送信号或消息进行交互的关联关系，包括关联、泛化、包含、扩展。 用例图的画法与步骤 确定研讨的系统：使用用例图 System框 表示一个待研究的系统，正确命名系统或子系统 识别 Actors：1.识别使用系统的主要参与者（primary actors）/角色(roles)，使用用例图 actor符号 表示，通常放在系统的左边。2.识别系统依赖的外部系统，使用用例图 Neighboursystem框 表示。 识别用例（服务）：识别用户级别用例，识别子功能级别的用例，正确使用用例与子用例之间的关系 建立 Actor 和 Use Cases 之间的关联，使用 无方向连线，表示两间之间是双向交互的协议 用例图给利益相关人与开发者的价值有哪些？ 获取需求、指导测试、还可在整个过程中的其它工作流起到指导作用。 帮助开发团队以一种可视化的方式理解系统的功能需求。 2、建模练习题（用例模型） 1- 选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求： 请使用用户的视角，描述用户目标或系统提供的服务 粒度达到子用例级别，并用 include 和 exclude 关联它们 请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例 尽可能识别外部系统和服务 2- 然后，回答下列问题： a.为什么相似系统的用例图是相似的？ 因为相似的系统需要满足的需求也十分相似，因此会有很多类似的功能和类似的拓展功能，因此用例图会比较相似。 b.如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术 对比之后发现，很显然携程的基本包含了Asg_RH含有的用例，另外它还有很多其他更多的功能 比如，携程拓展了很多其他拓展的业务，比如打车，旅游之类的，因此就会生成一些旅馆加打车券，景点票之类的组合优惠，更好的吸引客户。 交互部分，携程会更加简化，减少一些冗余或者不怎么重要的操作。 现在有了在线支付，所以携程提供了在线支付。 c.如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用 根据用例图中列出的功能可以看到哪些用例是其他系统中没有的，比如携程的低价信息功能，以此强化对这个用例的开发。 d.请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表 ID Name Imp Est How Notes 1 查找酒店 90 30 用户输入目的地、入住日期、退房日期、星级等信息，搜索酒店信息列表 需要对输入信息进行分析、GPS定位系统 2 下订单 100 30 用户选择酒店后，修改一些入住信息，并且确定入住 通过算法展示合适的结果给用户 3 支付 80 10 用户可以选择合适的支付方式 支付成功与否要给予反馈 e.根据任务4，参考 使用用例点估算软件成本，给出项目用例点的估算 用例名称 事务 计算 备注 查找酒店 3 2 简单 下订单 6 4 平均 支付 1 1 简单]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
        <tag>hw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-hw3]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-04-10-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-hw3.html</url>
    <content type="text"><![CDATA[简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点 从项目特点、风险特征、人力资源利用角度思考 瀑布模型： 优点：使用了线性的方法，将复杂问题转化为一系列简单的线性问题，然后逐个解决。有利于大型软件开发过程中人员的组织、管理，有利于软件开发方法和工具的研究，从而提高了大型软件项目开发的质量和效率。 缺点：(1)各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量. (2)由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险； (3)早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。 增量模型: 优点：增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险。 缺点：(1)并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构； (2)增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。 螺旋模型: 优点：螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。 缺点：(1)采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失； (2)过多的迭代次数会增加开发成本，延迟提交时间。 简述统一过程三大特点，与面向对象的方法有什么关系？ 统一过程三大特点：用例驱动、以构架为中心、迭代和增量的软件过程框架。 与面向对象的方法的关系：统一过程基于构件，它采用新的可视化建模标准，即统一建模语言UML。统一过程中的用例驱动体现用户的驱动开发，迭代式增量开发体现了风险驱动开发，而用户驱动的开发。UP面向功能类编程，架构设计接口，符合面向对象方法的特征。 简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？ 四个阶段的划分准则:每个阶段结束于一个主要的里程碑，并在阶段结尾执行一次评估以确定这个阶段的目标是否已经满足。 初始阶段。确立项目的边界，着重与需求和风险。结束里程碑是生命周期目标里程碑，生命周期目标里程碑评价项目基本的生存能力。 细化阶段。分析问题领域，建立基础结构，编写项目计划。结束于生命周期结构里程碑。生命周期结构里程碑为系统的结构建立了管理基准并使项目小组能够在构建阶段中进行衡量。 构造阶段。构建产品，进行测试。关键里程碑是初始功能里程碑。初始功能里程碑决定了产品是否可以在测试环境中进行部署。 交付阶段。确保软件可用。在交付阶段的终点是第四个里程碑：产品发布里程碑。此时，要确定目标是否实现，是否应该开始另一个开发周期。 软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？ 通过统一过程，各个阶段的生命周期是有固定长度的，因此在产品的的迭代开发过程有较为明确的时间限制的,软件企业就能按固定节奏生产、固定周期发布软件产品。 能够更好的的处理人力资源利用，项目风险等问题，使得项目更好的发展]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
        <tag>hw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-hw2]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-03-12-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-hw2.html</url>
    <content type="text"><![CDATA[一、简答题# 用简短的语言给出对分析、设计的理解。 分析：强调的是对问题和需求的调查研究，而不是解决方案。 设计：强调的是提出满足需求的概念上的解决方案（在软件方面和硬件方面），而不是其实现。 用一句话描述面向对象的分析与设计的优势。 面向对象的分析与设计，能够更好了解对象的需求，然后能更好、更快速的分析设计去满足对象的需求。 简述 UML（统一建模语言）的作用。考试考哪些图？ UML就是让我们针对这个系统，用图形的方式来互相交流，用图形的方式简单而懂；UML语言已经成为一个标准的语言，大家开发人员只要一看到某个图形就知道其包含的意义。 考试考的UML图： 用例视图：用例图 设计视图：类图、对象图 进程视图：序列图、协作图、状态图、活动图 实现视图：构件图 拓扑视图：部署图 从软件本质的角度，解释软件范围（需求）控制的可行性 由于软件本身的复杂性、不可见性、一致性、可变性，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程。因为有了这些特性，需求控制的必要性才凸显出来，但这些特性同时也带来了需求控制极高的难度，但是需求控制仍然是可以实现的。对于复杂性、可变性和不可视性这三个特性，决定了无法精确地完全地进行开发控制，但是一致性又表明软件工程是有些固定部分的，比如语法规范这样的确定的规则，所以可以从一个范围内，对软件的主要部分进行灵活的控制，规划可见的主要成本和潜在的未知成本。 二、项目管理实践# 看板使用练习（提交看板执行结果贴图，建议使用 Git project） UML绘图工具练习 教材 103页]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
        <tag>hw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-hw1]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F2019-03-12-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-hw1.html</url>
    <content type="text"><![CDATA[1.软件工程的定义# &nbsp;&nbsp;&nbsp;&nbsp;软件工程是将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件 2.解释导致 software crisis 本质原因、表现，述说克服软件危机的方法# &nbsp;&nbsp;&nbsp;&nbsp;本质原因：计算机的发展 表现：计算能力按摩尔定律发展，软件处理的问题也越来越广、越来约复杂 克服软件危机的方法：软件生产不只是编程技术问题，需要有系统化、与时俱进的软件工程方法，才能规避 software crisis ！ 3.软件生命周期# &nbsp;&nbsp;&nbsp;&nbsp;在时间维度，对软件项目任务进行划分，又成为软件开发过程。常见有瀑布模型、螺旋模型、敏捷的模型等。 4.SWEBoK 的 15 个知识域# 软件需求：软件要求KA关注软件需求的启发，协商，分析，规范和验证。 软件设计：软件设计KA涵盖了设计过程和最终产品。软件设计过程是软件工程生命周期活动，其中分析软件需求以产生软件内部结构及其行为的描述，其将作为其构造的基础。 软件构造：软件构建是指通过结合详细设计，编码，单元测试，集成测试，调试和验证来详细创建工作软件。 软件测试：测试是一项旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。 软件维护：软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。这些类别称为完善，自适应和纠正性软件维护。 软件配置管理：软件配置管理（SCM）是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。 软件工程管理：软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。 软件工程过程：软件工程KA关注软件生命周期过程的定义，实施，评估，测量，管理和改进。 软件工程模型和方法：软件工程模型和方法KA解决了涵盖多个生命周期阶段的方法; 其他KAs涵盖特定生命周期阶段的特定方法。 软件质量：软件质量是许多SWEBOK V3 KAs中普遍存在的软件生命周期问题。此外，软件质量KA还包括软件质量的基础知识; 软件质量管理流程; 和实际考虑。 软件工程职业实践：软件工程专业实践关注软件工程师必须具备的专业，负责和道德的软件工程知识，技能和态度。 软件工程经济学：软件工程经济学KA关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。 计算基础：计算基础KA涵盖了提供软件工程实践所需的计算背景的基础主题。 数学基础：数学基础KA涵盖了提供软件工程实践所必需的数学背景的基础主题。 工程基础：工程基础KA涵盖了提供软件工程实践所必需的工程背景的基础主题。 5.简单解释 CMMI 的五个级别。# 初始级：软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。 可管理级：建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。 已定义级：已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。 量化管理级：分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。 优化管理级：过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。 6.用自己语言简述 SWEBok 或 CMMI （约200字）# SWEBok就是软件工程知识体系指南，大致的讲述了一些主要的软件工程知识域，表明了软件工程的学科内容（包括工程和教育两个方面），把软件工程与其他学科的区别，帮助大家对软件工程有一致的观点。 CMMI就是软件能力成熟度集成模型，将一个组织划分成了几个不同的阶段级，需要不同的管理和开发结构。相比起普通的单一的组织框架，CMMI相对而言就更加灵活，可扩展，从总体上改进组织的质量和效率。CMMi包含了很多种管理，过程管理应该是用来帮助组织成长，项目管理可以让组织更加高效，稳定，工程管理则提供了更佳合理软件工程开发流程，就还有支持管理等等，通过这些标准可以快速的帮助一个组织建立以及发展，CMMI模型可以确保组织的更好的阶段性和连续性。]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
        <tag>hw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gRPC]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2019-01-19-gRPC.html</url>
    <content type="text"><![CDATA[简介# gRPC是一个高性能、开源和通用的RPC框架，面向移动和HTTP/2设计。 目前提供C、Java和Go语言版本，分别是grpc、grpc-java、grpc-go。 gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。 这些特性使得其在移动设备上表现更好，更省电和节省空间占用。 gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统。 gRPC是什么# 在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同机器上服务端应用的方法， 使得你能够更容易地创建分布式应用和服务。与许多RPC系统类似，gRPC也是基于以下理念： 定义一个服务，指定其能够被远程调用的方法（包括参数和返回类型）。 在服务端实现这个接口，并运行一个gRPC服务器来处理客户端调用。 在客户端拥有一个存根能够像服务端一样的方法。 gRPC客户端和服务端可以在多种环境中运行和交互，从google内部的服务器到你的笔记本，并且可以使用任何gRPC支持的语言编写。 所以你可以很容易滴用Java创建一个gRPC服务端，用go、python、ruby来创建客户端。 此外，google最新api将有gRPC版本的接口，使你很容易地将Google的功能集成到你的应用中。 安装# 1.安装 Protocol Buffers 12$ go get -u google.golang.org/grpc$ go get -u github.com/golang/protobuf/protoc-gen-go 2.安装gRPC-go gRPC-go可以通过golang 的get命令直接安装，非常方便。 1$ go get google.golang.org/grpc 3.编译例子 例子是gRPC-go的examples的helloworld,先看PB的描述： 123456789101112131415161718192021syntax = &quot;proto3&quot;;option objc_class_prefix = &quot;HLW&quot;;package helloworld;// The greeting service definition.service Greeter &#123; // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;&#125;// The request message containing the user&apos;s name.message HelloRequest &#123; string name = 1;&#125;// The response message containing the greetingsmessage HelloReply &#123; string message = 1;&#125; 使用protoc命令生成相关文件： 1$ protoc --go_out=plugins=grpc:. helloworld.proto 然后就会生成对应的pb.go文件了 4.编译运行 服务端 1$ go run greeter_server/main.go 客户端 1$ go run greeter_client/main.go 如果运行成功的话，可以在客户端看到 Greeting: Hello world。 5.代码部分： greeter_server/main.go声明并实现了 gRPC 的服务 SayHello 12345// SayHello implements helloworld.GreeterServerfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) &#123; log.Printf(&quot;Received: %v&quot;, in.Name) return &amp;pb.HelloReply&#123;Message: &quot;Hello &quot; + in.Name&#125;, nil&#125; greeter_client/main.go: 12345678// 连接 gPRC 服务conn, err := grpc.Dial(address, grpc.WithInsecure())// 创建一个 protobuf 客户端c := pb.NewGreeterClient(conn)// 调用 protobuf 的 SayHello 服务r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>服务计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swapi-xd]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-12-16-Swapi-xd.html</url>
    <content type="text"><![CDATA[Vue构建swapi前端的心得# 这次制作swapi的前端使用了vue架构，这个架构确实很方便，大致上的模仿复制了swpai的网站 开发过程# vue-cli的基本结构 我们需要去修改的文件基本上就是那个src里面的文件了。 首先是App.vue，在这里我主要书写了关于整个页面外面的框架，然后通过点击里面导航栏里面的按钮结合router实现相对应的页面跳转。 并且在js文件里面配置那个router 然后根据页面的内容进行相应的布局，在about和docu两个页面里面使用markdown-loader去允许读取md文件，并且vue-markdown去显示md文件。 然后在md内置a的tag就可以实现那个点击的跳转了。 在主页面里面用一个pre去显示那个json的输出口 关于那个api的请求，则是使用axios去发出请求并且处理response就可以显示结果了。 最后网页是大致与原站差不多的。]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>服务计算</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go的web小程序及http包分析]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-11-15-Go-http.html</url>
    <content type="text"><![CDATA[简单的web服务器# 这是一个简单的输出hello world！的web服务器，只用在客户端访问 http://localhost:9090/ 就可以获得响应内容。 1234567891011121314151617181920package mainimport ( "fmt" "net/http" "strings" "log")func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte("Hello World!"))&#125;func main() &#123; http.HandleFunc("/", sayhelloName) //设置访问的路由 err := http.ListenAndServe(":9090", nil) //设置监听的端口 if err != nil &#123; log.Fatal("ListenAndServe: ", err) &#125;&#125; 这段代码很简单，就主要是是用了两个函数，首先调用http.HandleFunc()设置路由和响应处理函数，然后用http.ListenAndServe()去监听端口，就好了。 HandleFunc()分析# http.HandleFunc()的定义，用来使用对应的函数。 1234// HandleFunc registers the handler function for the given pattern.func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123; mux.Handle(pattern, HandlerFunc(handler))&#125; 可以看出来上面就是用来mux.Handle函数，Http包默认的路由器：DefaultServeMux, 它的ServeMux的结构看起来好像很简单。 上述代码中，实现了Handler接口的ServeHTTP方法。使用HandlerFunc类型包装一下路由定义的indexHandler函数，其目的就是为了让这个函数也实现ServeHTTP方法，即转变成一个handler处理器(函数)。 12345678910type ServeMux struct &#123; mu sync.RWMutex m map[string]muxEntry hosts bool &#125;type muxEntry struct &#123; explicit bool h Handler pattern string&#125; ServeMux里最重要的应该就是m了，这个map的key是一些url模式，value是一个muxEntry结构，后者里定义存储了具体的url模式和handler。 根据HandleFunc的输入就可以，开始调用mux.Handle函数了。 12345678910111213141516171819202122232425262728293031323334353637// Handle registers the handler for the given pattern.// If a handler already exists for pattern, Handle panics.func (mux *ServeMux) Handle(pattern string, handler Handler) &#123; mux.mu.Lock() defer mux.mu.Unlock() if pattern == "" &#123; if pattern == "" &#123; panic("http: invalid pattern " + pattern) &#125; if handler == nil &#123; panic("http: nil handler") &#125; if mux.m[pattern].explicit &#123; panic("http: multiple registrations for " + pattern) &#125; if mux.m == nil &#123; mux.m = make(map[string]muxEntry) &#125; mux.m[pattern] = muxEntry&#123;explicit: true, h: handler, pattern: pattern&#125; if pattern[0] != '/' &#123; mux.hosts = true &#125; n := len(pattern) if n &gt; 0 &amp;&amp; pattern[n-1] == '/' &amp;&amp; !mux.m[pattern[0:n-1]].explicit &#123; path := pattern if pattern[0] != '/' &#123; path = pattern[strings.Index(pattern, "/"):] &#125; url := &amp;url.URL&#123;Path: path&#125; mux.m[pattern[0:n-1]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125; &#125;&#125; 由此可见，Handle函数的主要目的在于把handler和pattern模式绑定到map[string]muxEntry的map上，其中muxEntry保存了更多pattern和handler的信息， ListenAndServe()分析# 1234func ListenAndServe(addr string, handler Handler) error &#123; server := &amp;Server&#123;Addr: addr, Handler: handler&#125; return server.ListenAndServe()&#125; 先实例化一个Server对象，然后调用 (Server) ListenAndServe()方法进行监听： 1234567891011func (srv *Server) ListenAndServe() error &#123; addr := srv.Addr if addr == "" &#123; addr = ":http" &#125; ln, err := net.Listen("tcp", addr) //监听端口 if err != nil &#123; return err &#125; return srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)&#125; 函数 srv.Serve()函数启动一个for循环，然后在循环体中Accept请求，对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()。 1234567891011121314151617181920212223242526272829func (srv *Server) Serve(l net.Listener) error &#123; defer l.Close() var tempDelay time.Duration // how long to sleep on accept failure for &#123; rw, e := l.Accept() //通过Listener接收请求 if e != nil &#123; if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123; if tempDelay == 0 &#123; tempDelay = 5 * time.Millisecond &#125; else &#123; tempDelay *= 2 &#125; if max := 1 * time.Second; tempDelay &gt; max &#123; tempDelay = max &#125; log.Printf("http: Accept error: %v; retrying in %v", e, tempDelay) time.Sleep(tempDelay) continue &#125; return e &#125; tempDelay = 0 c, err := srv.newConn(rw) //创建一个Conn。Conn是net包里面的一个接口 type Conn interface。Conn接口代表通用的面向流的网络连接。多个线程可能会同时调用同一个Conn的方法。 if err != nil &#123; continue &#125; go c.serve() //Go语言高并发的体现 &#125;&#125; 搭建一个web服务器# 一个简单的服务器，所以就没有使用牛逼的框架，就用了老师给的 “github.com/codegangsta/negroni&quot;、“github.com/gorilla/mux”、&quot;github.com/unrolled/render” 这三个。 Server注册路由# 用HandleFunc给每种访问提供对应的处理路由。 表单处理# 通过PaeseForm，提取表单内部的数据值。 处理完回应# 将你的数据转化成页面写上去。 实现效果# 登入 注册，传表单 登入查看对应内容 静态文件服务 /unknown 代码连接]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>服务计算</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7下搭建Golang]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-09-27-Go-some.html</url>
    <content type="text"><![CDATA[配置VSCode# 官方教程 首先，必须明确的是CentOS即不是Debian也不是Ubuntu，所以不要输入最上面的那几行命令。要输入后面的那一坨,一步一步走就好。 安装密钥和存储库# 12sudo rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo sh -c &apos;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&apos; 更新包缓存并安装包# 因为CentOS比较low，使用旧版的yum： 12yum check-updatesudo yum install code VScode的位置# 由于桌面上并没有这玩意儿，所以需要到应用程序里面找。 下载安装 golang# 1sudo yum install golang 就会自动下载安装包的了，下载完后会问你是否安装的，输入y继续安装好就行。 1rpm -ql golang |more 查询golang的安装路径 1go version 查看go的版本 配置go环境# 因为go安装的时候已经自动的设置了一个默认的环境，可以用go env来查看当前的go环境设置，会发现GOPATH=“/root/go”，这会导致一些权限问题，所以最好还是要修改一下环境的配置。 创建工作空间 1mkdir $HOME/gowork 配置的环境变量,把下面的代码添加到[~/.profile]里面。 12export GOPATH=$HOME/goworkexport PATH=$PATH:$GOPATH/bin 使环境变量生效 1source $HOME/.profile 现在可以再查看一下环境看一下变化 1go env 创建一个helloworld# 创建源代码目录： 1mkdir $GOPATH/src/github.com/github-user/hello -p 使用 vs code 创建 hello.go 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Printf(&quot;hello, world\n&quot;)&#125; 在终端运行! 12$ go run hello.gohello, world 这样简单的helloworld程序就完成了。 安装工具插件# 安装git# go 语言的插件主要在 Github 上，安装 git 客户端是首要工作。 1$ sudo yum install git 接着就是去配置一下git 12$ git config --global user.name &quot;你的名字&quot;$ git config --global user.email 你的邮箱 git的基本操作就不多说了。 安装 go 的一些工具# vscode会提示我们去安装一些插件，但很难受的是有些插件不能成功安装，“Failed”，所以需要在github里面寻求帮助。 123456# 创建文件夹mkdir $GOPATH/src/golang.org/x/# 下载源码go get -d github.com/golang/tools# copy cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf 此处，本人不知道遇到了什么问题，第二步发生了什么，无法直接下载源代码，此处别人都是正常的！ 我没有发现问题根源，于是选择直接去git clone下文件，拖进文件夹里，貌似并不会影响下面的操作,某个lint的插件同理可得。 1git clone https://github.com/golang/tools.git 接下来就是安装工具包 1$ go install golang.org/x/tools/go/buildutil 然后，在登入到VScode里，跟之前一样点那个提示安装就可以“Succeed”了！ 接下来就可以安装运行hello world了 12$ go install github.com/github-user/hello$ hello Go Tour# 这就是一个go的基本操作教程，安装完就可以直接用了，可以在线编程测试，相当方便，适合go语言的练习使用。 安装 1$ go get github.com/Go-zh/tour/gotour 运行 1$ gotour 这样就基本完成了CentOS的环境搭建，接下来就可以开始Go语言之旅了！！！]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>服务计算</tag>
        <tag>颓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware 搭建私有云]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-09-20-Pri-cloud.html</url>
    <content type="text"><![CDATA[1.实验目的# 1.初步了解虚拟化技术，理解云计算的相关概念 2.为后续课程提供统一的编程与实验环境 3.理解系统工程师面临的困境 2.实验环境与要求# 用户通过互联网，使用微软远程桌面，远程访问你在PC机上创建的虚拟机 虚拟机操作系统 Centos，Ubuntu，或 你喜欢的 Linux 发行版，能使用 NAT 访问外网。 3. 实验内容# 1.安装 VMWare# 进入官网，选择合适版本的VMWare进行下载，并根据流程一步一步的完成安装. &nbsp; [官网下载](https://www.vmware.com/) 2.使用VMware配置虚拟机# 创建一个虚拟机。这里选择的是CentOS7的精简版（Minimal ISO），可以在CentOS官网下载（节点可选择清华开源镜像站高速下载，速度较快）。 打开VMWare，创建虚拟机： 创建新的虚拟机 选择“典型（推荐）” 客户机操作系统选择Linux，版本为CentOS 64位(VMWare会自动识别，在VBox这里不要改版本，因为CentOS本身就是继承Red Hat的系统) 选择虚拟机安装位置 磁盘大小选择30g或以上 内存选择2G ，双核（有条件就不用拘泥了） 完成 接着，就是虚拟机网络设置，VMWare已经配置好了NAT模式和仅主机模式，所以进入后就可以直接连外网和主机了。 3.安装虚拟机# 启动虚拟机会进入centos的安装程序。按照安装程序一步一步来。 安装位置，选择自动分区即可 打开”网络与主机名“设置，把网卡打开，并且修改主机名 开始安装 设置root密码，可以创建用户 安装完重启,登入时如果没有用户，则可用用户名为root的方式登入 升级os内核 yum install wget 获取 wget yum update 升级 OS 内核。 检查网络 ping www.baidu.com 检查外网(这里我之前出现了一个DNS域名解析的bug，误以为网络问题，且未解决，可尝试连接外网的ip，如百度的119.75.217.109) ping 192.168.100.1 检查内网 ifconfig 查看网络 nmtui 配置网络 4.复制虚拟机# 右键点击centos-base虚拟机，选择【管理】-&gt;【克隆】 选择链接复制 VMWare应该是自带修改MAC地址的，就不用手动改了 vim /etc/ssh/sshd_config把里面Port 22前的#去掉，以及PermitRootLogin yes前面的#去掉。 然后service sshd start开启服务 用ssh 用户名@虚拟机ip地址去访问虚拟机 5.远程连接# 选择编辑–虚拟网络编辑器 点击NAT设置，弹出一个设置窗口 添加一个端口转发 配置路由器 就可以通过WAN口IP连接了(ssh -p 端口号 用户名@WAN口IP) 6.远程桌面连接# yum -y groupinstall &quot;GNOME Desktop&quot; 安装桌面 ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 设置启动目标为桌面 重启 安装epel 、xrdp、tigervnc-server yum install epel-release yum install xrdp yum install tigervnc-server 关闭防火墙，启动xrdp systemctl stop firewalld systemctl disable firewalld systemctl start xrdp systemctl enable xrdp 这样就实现了远程桌面连接]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>服务计算</tag>
        <tag>颓</tag>
        <tag>云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F2016-11-09-hello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start# Create a new post# 1$ hexo new "My New Post" More info: Writing Run server# 1$ hexo server More info: Server Generate static files# 1$ hexo generate More info: Generating Deploy to remote sites# 1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
