<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go的http包源码分析]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-11-15-Go-http.html</url>
    <content type="text"><![CDATA[简单的web服务器# 这是一个简单的输出hello world！的web服务器，只用在客户端访问 http://localhost:9090/ 就可以获得响应内容。 1234567891011121314151617181920package mainimport ( "fmt" "net/http" "strings" "log")func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte("Hello World!"))&#125;func main() &#123; http.HandleFunc("/", sayhelloName) //设置访问的路由 err := http.ListenAndServe(":9090", nil) //设置监听的端口 if err != nil &#123; log.Fatal("ListenAndServe: ", err) &#125;&#125; 这段代码很简单，就主要是是用了两个函数，首先调用http.HandleFunc()设置路由和响应处理函数，然后用http.ListenAndServe()去监听端口，就好了。 HandleFunc()分析# http.HandleFunc()的定义，用来使用对应的函数。 1234// HandleFunc registers the handler function for the given pattern.func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123; mux.Handle(pattern, HandlerFunc(handler))&#125; 可以看出来上面就是用来mux.Handle函数，Http包默认的路由器：DefaultServeMux, 它的ServeMux的结构看起来好像很简单。 上述代码中，实现了Handler接口的ServeHTTP方法。使用HandlerFunc类型包装一下路由定义的indexHandler函数，其目的就是为了让这个函数也实现ServeHTTP方法，即转变成一个handler处理器(函数)。 12345678910type ServeMux struct &#123; mu sync.RWMutex m map[string]muxEntry hosts bool &#125;type muxEntry struct &#123; explicit bool h Handler pattern string&#125; ServeMux里最重要的应该就是m了，这个map的key是一些url模式，value是一个muxEntry结构，后者里定义存储了具体的url模式和handler。 根据HandleFunc的输入就可以，开始调用mux.Handle函数了。 12345678910111213141516171819202122232425262728293031323334353637// Handle registers the handler for the given pattern.// If a handler already exists for pattern, Handle panics.func (mux *ServeMux) Handle(pattern string, handler Handler) &#123; mux.mu.Lock() defer mux.mu.Unlock() if pattern == "" &#123; if pattern == "" &#123; panic("http: invalid pattern " + pattern) &#125; if handler == nil &#123; panic("http: nil handler") &#125; if mux.m[pattern].explicit &#123; panic("http: multiple registrations for " + pattern) &#125; if mux.m == nil &#123; mux.m = make(map[string]muxEntry) &#125; mux.m[pattern] = muxEntry&#123;explicit: true, h: handler, pattern: pattern&#125; if pattern[0] != '/' &#123; mux.hosts = true &#125; n := len(pattern) if n &gt; 0 &amp;&amp; pattern[n-1] == '/' &amp;&amp; !mux.m[pattern[0:n-1]].explicit &#123; path := pattern if pattern[0] != '/' &#123; path = pattern[strings.Index(pattern, "/"):] &#125; url := &amp;url.URL&#123;Path: path&#125; mux.m[pattern[0:n-1]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125; &#125;&#125; 由此可见，Handle函数的主要目的在于把handler和pattern模式绑定到map[string]muxEntry的map上，其中muxEntry保存了更多pattern和handler的信息， ListenAndServe()分析# 1234func ListenAndServe(addr string, handler Handler) error &#123; server := &amp;Server&#123;Addr: addr, Handler: handler&#125; return server.ListenAndServe()&#125; 先实例化一个Server对象，然后调用 (Server) ListenAndServe()方法进行监听： 1234567891011func (srv *Server) ListenAndServe() error &#123; addr := srv.Addr if addr == "" &#123; addr = ":http" &#125; ln, err := net.Listen("tcp", addr) //监听端口 if err != nil &#123; return err &#125; return srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)&#125; 函数 srv.Serve()函数启动一个for循环，然后在循环体中Accept请求，对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()。 1234567891011121314151617181920212223242526272829func (srv *Server) Serve(l net.Listener) error &#123; defer l.Close() var tempDelay time.Duration // how long to sleep on accept failure for &#123; rw, e := l.Accept() //通过Listener接收请求 if e != nil &#123; if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123; if tempDelay == 0 &#123; tempDelay = 5 * time.Millisecond &#125; else &#123; tempDelay *= 2 &#125; if max := 1 * time.Second; tempDelay &gt; max &#123; tempDelay = max &#125; log.Printf("http: Accept error: %v; retrying in %v", e, tempDelay) time.Sleep(tempDelay) continue &#125; return e &#125; tempDelay = 0 c, err := srv.newConn(rw) //创建一个Conn。Conn是net包里面的一个接口 type Conn interface。Conn接口代表通用的面向流的网络连接。多个线程可能会同时调用同一个Conn的方法。 if err != nil &#123; continue &#125; go c.serve() //Go语言高并发的体现 &#125;&#125; 搭建一个web服务器# 一个简单的服务器，所以就没有使用牛逼的框架，就用了老师给的 “github.com/codegangsta/negroni&quot;、“github.com/gorilla/mux”、&quot;github.com/unrolled/render” 这三个。 Server注册路由# 用HandleFunc给每种访问提供对应的处理路由。 表单处理# 通过PaeseForm，提取表单内部的数据值。 处理完回应# 将你的数据转化成页面写上去。 实现效果# 登入 注册，传表单 登入查看对应内容 静态文件服务 /unknown 代码连接]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>服务计算</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7下搭建Golang]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-09-27-Go-some.html</url>
    <content type="text"><![CDATA[配置VSCode# 官方教程 首先，必须明确的是CentOS即不是Debian也不是Ubuntu，所以不要输入最上面的那几行命令。要输入后面的那一坨,一步一步走就好。 安装密钥和存储库# 12sudo rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo sh -c &apos;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&apos; 更新包缓存并安装包# 因为CentOS比较low，使用旧版的yum： 12yum check-updatesudo yum install code VScode的位置# 由于桌面上并没有这玩意儿，所以需要到应用程序里面找。 下载安装 golang# 1sudo yum install golang 就会自动下载安装包的了，下载完后会问你是否安装的，输入y继续安装好就行。 1rpm -ql golang |more 查询golang的安装路径 1go version 查看go的版本 配置go环境# 因为go安装的时候已经自动的设置了一个默认的环境，可以用go env来查看当前的go环境设置，会发现GOPATH=“/root/go”，这会导致一些权限问题，所以最好还是要修改一下环境的配置。 创建工作空间 1mkdir $HOME/gowork 配置的环境变量,把下面的代码添加到[~/.profile]里面。 12export GOPATH=$HOME/goworkexport PATH=$PATH:$GOPATH/bin 使环境变量生效 1source $HOME/.profile 现在可以再查看一下环境看一下变化 1go env 创建一个helloworld# 创建源代码目录： 1mkdir $GOPATH/src/github.com/github-user/hello -p 使用 vs code 创建 hello.go 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Printf(&quot;hello, world\n&quot;)&#125; 在终端运行! 12$ go run hello.gohello, world 这样简单的helloworld程序就完成了。 安装工具插件# 安装git# go 语言的插件主要在 Github 上，安装 git 客户端是首要工作。 1$ sudo yum install git 接着就是去配置一下git 12$ git config --global user.name &quot;你的名字&quot;$ git config --global user.email 你的邮箱 git的基本操作就不多说了。 安装 go 的一些工具# vscode会提示我们去安装一些插件，但很难受的是有些插件不能成功安装，“Failed”，所以需要在github里面寻求帮助。 123456# 创建文件夹mkdir $GOPATH/src/golang.org/x/# 下载源码go get -d github.com/golang/tools# copy cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf 此处，本人不知道遇到了什么问题，第二步发生了什么，无法直接下载源代码，此处别人都是正常的！ 我没有发现问题根源，于是选择直接去git clone下文件，拖进文件夹里，貌似并不会影响下面的操作,某个lint的插件同理可得。 1git clone https://github.com/golang/tools.git 接下来就是安装工具包 1$ go install golang.org/x/tools/go/buildutil 然后，在登入到VScode里，跟之前一样点那个提示安装就可以“Succeed”了！ 接下来就可以安装运行hello world了 12$ go install github.com/github-user/hello$ hello Go Tour# 这就是一个go的基本操作教程，安装完就可以直接用了，可以在线编程测试，相当方便，适合go语言的练习使用。 安装 1$ go get github.com/Go-zh/tour/gotour 运行 1$ gotour 这样就基本完成了CentOS的环境搭建，接下来就可以开始Go语言之旅了！！！]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>服务计算</tag>
        <tag>颓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware 搭建私有云]]></title>
    <url>%2Fposts%2F%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%2F2018-09-20-Pri-cloud.html</url>
    <content type="text"><![CDATA[1.实验目的# 1.初步了解虚拟化技术，理解云计算的相关概念 2.为后续课程提供统一的编程与实验环境 3.理解系统工程师面临的困境 2.实验环境与要求# 用户通过互联网，使用微软远程桌面，远程访问你在PC机上创建的虚拟机 虚拟机操作系统 Centos，Ubuntu，或 你喜欢的 Linux 发行版，能使用 NAT 访问外网。 3. 实验内容# 1.安装 VMWare# 进入官网，选择合适版本的VMWare进行下载，并根据流程一步一步的完成安装. &nbsp; [官网下载](https://www.vmware.com/) 2.使用VMware配置虚拟机# 创建一个虚拟机。这里选择的是CentOS7的精简版（Minimal ISO），可以在CentOS官网下载（节点可选择清华开源镜像站高速下载，速度较快）。 打开VMWare，创建虚拟机： 创建新的虚拟机 选择“典型（推荐）” 客户机操作系统选择Linux，版本为CentOS 64位(VMWare会自动识别，在VBox这里不要改版本，因为CentOS本身就是继承Red Hat的系统) 选择虚拟机安装位置 磁盘大小选择30g或以上 内存选择2G ，双核（有条件就不用拘泥了） 完成 接着，就是虚拟机网络设置，VMWare已经配置好了NAT模式和仅主机模式，所以进入后就可以直接连外网和主机了。 3.安装虚拟机# 启动虚拟机会进入centos的安装程序。按照安装程序一步一步来。 安装位置，选择自动分区即可 打开”网络与主机名“设置，把网卡打开，并且修改主机名 开始安装 设置root密码，可以创建用户 安装完重启,登入时如果没有用户，则可用用户名为root的方式登入 升级os内核 yum install wget 获取 wget yum update 升级 OS 内核。 检查网络 ping www.baidu.com 检查外网(这里我之前出现了一个DNS域名解析的bug，误以为网络问题，且未解决，可尝试连接外网的ip，如百度的119.75.217.109) ping 192.168.100.1 检查内网 ifconfig 查看网络 nmtui 配置网络 4.复制虚拟机# 右键点击centos-base虚拟机，选择【管理】-&gt;【克隆】 选择链接复制 VMWare应该是自带修改MAC地址的，就不用手动改了 vim /etc/ssh/sshd_config把里面Port 22前的#去掉，以及PermitRootLogin yes前面的#去掉。 然后service sshd start开启服务 用ssh 用户名@虚拟机ip地址去访问虚拟机 5.远程连接# 选择编辑–虚拟网络编辑器 点击NAT设置，弹出一个设置窗口 添加一个端口转发 配置路由器 就可以通过WAN口IP连接了(ssh -p 端口号 用户名@WAN口IP) 6.远程桌面连接# yum -y groupinstall &quot;GNOME Desktop&quot; 安装桌面 ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 设置启动目标为桌面 重启 安装epel 、xrdp、tigervnc-server yum install epel-release yum install xrdp yum install tigervnc-server 关闭防火墙，启动xrdp systemctl stop firewalld systemctl disable firewalld systemctl start xrdp systemctl enable xrdp 这样就实现了远程桌面连接]]></content>
      <categories>
        <category>服务计算</category>
      </categories>
      <tags>
        <tag>服务计算</tag>
        <tag>颓</tag>
        <tag>云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F2016-11-09-hello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start# Create a new post# 1$ hexo new "My New Post" More info: Writing Run server# 1$ hexo server More info: Server Generate static files# 1$ hexo generate More info: Generating Deploy to remote sites# 1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
